#ifndef LIB_RUBY_PARSER_MESSAGE_VARIANT_H
#define LIB_RUBY_PARSER_MESSAGE_VARIANT_H

#include <string>
#include <variant>
#include <memory>
#include "message_classes.h"

namespace lib_ruby_parser {

using diagnostic_message_variant_t = std::variant<
    std::unique_ptr<FractionAfterNumeric>,
    std::unique_ptr<NoDigitsAfterDot>,
    std::unique_ptr<UnknownTypeOfPercentString>,
    std::unique_ptr<NumericLiteralWithoutDigits>,
    std::unique_ptr<UnterminatedList>,
    std::unique_ptr<UnterminatedRegexp>,
    std::unique_ptr<UnterminatedString>,
    std::unique_ptr<UnterminatedQuotedString>,
    std::unique_ptr<InvalidUnicodeEscape>,
    std::unique_ptr<TooLargeUnicodeCodepoint>,
    std::unique_ptr<InvalidUnicodeCodepoint>,
    std::unique_ptr<MultipleCodepointAtSingleChar>,
    std::unique_ptr<InvalidEscapeCharacter>,
    std::unique_ptr<InvalidHexEscape>,
    std::unique_ptr<UnterminatedHeredoc>,
    std::unique_ptr<UnterminatedHeredocId>,
    std::unique_ptr<SlashRAtMiddleOfLine>,
    std::unique_ptr<DStarInterpretedAsArgPrefix>,
    std::unique_ptr<StarInterpretedAsArgPrefix>,
    std::unique_ptr<AmpersandInterpretedAsArgPrefix>,
    std::unique_ptr<TripleDotAtEol>,
    std::unique_ptr<ParenthesesIterpretedAsArglist>,
    std::unique_ptr<AmbiguousFirstArgument>,
    std::unique_ptr<AmbiguousOperator>,
    std::unique_ptr<InvalidCharacterSyntax>,
    std::unique_ptr<InvalidOctalDigit>,
    std::unique_ptr<TrailingCharInNumber>,
    std::unique_ptr<EmbeddedDocumentMeetsEof>,
    std::unique_ptr<InvalidChar>,
    std::unique_ptr<IncompleteCharacterSyntax>,
    std::unique_ptr<GvarWithoutId>,
    std::unique_ptr<InvalidGvarName>,
    std::unique_ptr<IvarWithoutId>,
    std::unique_ptr<InvalidIvarName>,
    std::unique_ptr<CvarWithoutId>,
    std::unique_ptr<InvalidCvarName>,
    std::unique_ptr<UnknownRegexOptions>,
    std::unique_ptr<UnterminatedUnicodeEscape>,
    std::unique_ptr<EncodingError>,
    std::unique_ptr<AmbiguousTernaryOperator>,
    std::unique_ptr<AmbiguousRegexp>,
    std::unique_ptr<ElseWithoutRescue>,
    std::unique_ptr<BeginNotAtTopLevel>,
    std::unique_ptr<AliasNthRef>,
    std::unique_ptr<CsendInsideMasgn>,
    std::unique_ptr<ClassOrModuleNameMustBeConstant>,
    std::unique_ptr<EndlessSetterDefinition>,
    std::unique_ptr<UnexpectedToken>,
    std::unique_ptr<ClassDefinitionInMethodBody>,
    std::unique_ptr<ModuleDefinitionInMethodBody>,
    std::unique_ptr<InvalidReturnInClassOrModuleBody>,
    std::unique_ptr<ConstArgument>,
    std::unique_ptr<IvarArgument>,
    std::unique_ptr<GvarArgument>,
    std::unique_ptr<CvarArgument>,
    std::unique_ptr<NoSuchLocalVariable>,
    std::unique_ptr<OrdinaryParamDefined>,
    std::unique_ptr<NumparamUsed>,
    std::unique_ptr<TokAtEolWithoutExpression>,
    std::unique_ptr<EndInMethod>,
    std::unique_ptr<ComparisonAfterComparison>,
    std::unique_ptr<CircularArgumentReference>,
    std::unique_ptr<DynamicConstantAssignment>,
    std::unique_ptr<CantAssignToSelf>,
    std::unique_ptr<CantAssignToNil>,
    std::unique_ptr<CantAssignToTrue>,
    std::unique_ptr<CantAssignToFalse>,
    std::unique_ptr<CantAssignToFile>,
    std::unique_ptr<CantAssignToLine>,
    std::unique_ptr<CantAssignToEncoding>,
    std::unique_ptr<CantAssignToNumparam>,
    std::unique_ptr<CantSetVariable>,
    std::unique_ptr<BlockGivenToYield>,
    std::unique_ptr<BlockAndBlockArgGiven>,
    std::unique_ptr<SymbolLiteralWithInterpolation>,
    std::unique_ptr<ReservedForNumparam>,
    std::unique_ptr<KeyMustBeValidAsLocalVariable>,
    std::unique_ptr<DuplicateVariableName>,
    std::unique_ptr<DuplicateKeyName>,
    std::unique_ptr<SingletonLiteral>,
    std::unique_ptr<NthRefIsTooBig>,
    std::unique_ptr<DuplicatedArgumentName>,
    std::unique_ptr<RegexError>,
    std::unique_ptr<InvalidSymbol>,
    std::unique_ptr<VoidValueExpression>
>;

}

#endif // LIB_RUBY_PARSER_MESSAGE_VARIANT_H
