use lib_ruby_parser_nodes::{template::*, MessageField};

const TEMPLATE: &str = "// This file is autogenerated by {{ helper generated-by }}

#include <cstring>
#include \"messages.hpp\"
#include \"utils.hpp\"

namespace lib_ruby_parser
{
    extern \"C\"
    {
        void LIB_RUBY_PARSER_drop_message(DiagnosticMessage *message);
    }

    DiagnosticMessage::Value::Value() {
        std::memset(this, 0, sizeof(Value));
    }
    DiagnosticMessage::Value::Value(DiagnosticMessage::Value &&other) {
        std::memcpy(this, &other, sizeof(Value));
        std::memset(&other, 0, sizeof(Value));
    };
    DiagnosticMessage::Value::~Value() {}

    DiagnosticMessage::Value &DiagnosticMessage::Value::operator=(DiagnosticMessage::Value &&other) {
        std::memcpy(this, &other, sizeof(Value));
        std::memset(&other, 0, sizeof(Value));
        return *this;
    }

    DiagnosticMessage::DiagnosticMessage(DiagnosticMessage &&other):
        tag(other.tag),
        as(std::move(other.as)) {}
    DiagnosticMessage::~DiagnosticMessage() {
        LIB_RUBY_PARSER_drop_message(this);
    }

    DiagnosticMessage &DiagnosticMessage::operator=(DiagnosticMessage &&other) {
        this->tag = other.tag;
        this->as = std::move(other.as);
        return *this;
    }

    LIST_IMPL(DiagnosticMessageList, DiagnosticMessage, LIB_RUBY_PARSER_drop_message_list);

    // Mesasge variant constructors
{{ each message }}
    {{ helper message-camelcase-name }}::{{ helper message-camelcase-name }}(<dnl>
{{ each message-field }}<dnl>
{{ helper message-field-c-field-type }} {{ helper message-field-c-name }}_<dnl>
{{ if message-field-is-last }}{{ else }}, {{ end }}{{ end }}<dnl>
){{ if message-has-no-fields }}{{ else }} : {{ each message-field }}<dnl>
{{ helper message-field-c-name }}(std::move({{ helper message-field-c-name }}_))<dnl>
{{ if message-field-is-last }}{{ else }}, {{ end }}<dnl>
{{ end }}{{ end }} {}
{{ end }}

    // Diagnostic constructors
{{ each message }}
    DiagnosticMessage::DiagnosticMessage({{ helper message-camelcase-name }} variant) : tag(DiagnosticMessage::Tag::{{ helper message-upper-name }}) {
        this->as.{{ helper message-lower-name }} = std::move(variant);
    }
{{ end }}
} // namespace lib_ruby_parser

#ifdef TEST_ENV

#include \"test_helper.hpp\"

#define assert_expected_str_value(str) \\
    assert_string_eq((str), \"foo\")

#define assert_expected_u8_value(u8) \\
    assert_eq((u8), 42)

#define assert_expected_messages_value(messages) \\
    assert_eq((messages).len, 1); \\
    assert_eq((messages).ptr[0].tag, DiagnosticMessage::Tag::FRACTION_AFTER_NUMERIC)

namespace lib_ruby_parser {

    BLOB(DiagnosticMessage);
    BLOB(DiagnosticMessageList);

{{ each message }}<dnl>
    extern \"C\"
    {
        DiagnosticMessageBlob lib_ruby_parser__test__make_{{ helper message-lower-name }}_message(void);
    }
    static void test_message_{{ helper message-lower-name }}(void)
    {
        annotate_test;

        DiagnosticMessage message = from_blob<DiagnosticMessageBlob, DiagnosticMessage>(
            lib_ruby_parser__test__make_{{ helper message-lower-name }}_message());
        assert_eq(message.tag, DiagnosticMessage::Tag::{{ helper message-upper-name }});
        {{ helper message-camelcase-name }} *variant = &message.as.{{ helper message-lower-name }};
{{ each message-field }}<dnl>
        {{ helper assert-field-fn }}(variant->{{ helper message-field-c-name }});
{{ end }}<dnl>
        (void)variant;

        // make sure it's movable
        DiagnosticMessage message_to_move = from_blob<DiagnosticMessageBlob, DiagnosticMessage>(
            lib_ruby_parser__test__make_{{ helper message-lower-name }}_message());
        DiagnosticMessage moved = std::move(message_to_move);
    }
{{ end }}<dnl>

    extern \"C\"
    {
        DiagnosticMessageListBlob lib_ruby_parser__test__make_message_list(void);
    }
    static void test_message_list(void)
    {
        annotate_test;

        DiagnosticMessageList message_list = from_blob<DiagnosticMessageListBlob, DiagnosticMessageList>(
            lib_ruby_parser__test__make_message_list());
        assert_expected_messages_value(message_list);
    }

    void run_test_group_message(void)
    {
        const test_fn_t tests[] = {
{{ each message }}<dnl>
            test_message_{{ helper message-lower-name }},
{{ end }}<dnl>
            test_message_list,
        };

        run_tests_as_group(\"message\", tests, sizeof(tests) / sizeof(test_fn_t));
    }
}

#endif
";

pub(crate) fn codegen() {
    let template = TemplateRoot::new(TEMPLATE).unwrap();
    let mut fns = crate::codegen::fns::default_fns!();

    fns.register::<MessageField, F::Helper>("assert-field-fn", helpers::assert_field_fn);

    let contents = template.render(ALL_DATA, &fns);
    std::fs::write("../messages.cpp", contents).unwrap();
}

mod helpers {
    use lib_ruby_parser_nodes::MessageField;

    pub(crate) fn assert_field_fn(message_field: &MessageField) -> String {
        use lib_ruby_parser_nodes::MessageFieldType::*;

        match message_field.field_type {
            Str => "assert_expected_str_value",
            Byte => "assert_expected_u8_value",
        }
        .to_string()
    }
}
