use lib_ruby_parser_nodes::template::*;

const TEMPLATE: &str = "#ifndef LIB_RUBY_PARSER_MESSAGES_HPP
#define LIB_RUBY_PARSER_MESSAGES_HPP

// This file is autogenerated by {{ helper generated-by }}

#include <cstdint>
#include \"string.hpp\"

namespace lib_ruby_parser
{
{{ each message }}<dnl>
{{ helper message-comment }}
    class {{ helper message-camelcase-name }}
    {
    public:
{{ if message-has-no-fields }}<dnl>
        // dummy byte (zero-sized structs are no allowed in C)
        uint8_t dummy;
{{ else }}<dnl>
{{ end }}<dnl>
<dnl>
{{ each message-field }}<dnl>
    {{ helper message-field-comment }}
        {{ helper message-field-c-field-type }} {{ helper message-field-c-name }};
{{ end }}<dnl>

{{ if message-has-no-fields }}<dnl>
{{ else }}<dnl>
        {{ helper message-camelcase-name }}() = delete;
{{ end }}<dnl>
        {{ helper message-camelcase-name }}(<dnl>
{{ each message-field }}<dnl>
{{ helper message-field-c-field-type }} {{ helper message-field-c-name }}<dnl>
{{ if message-field-is-last }}{{ else }}, {{ end }}{{ end }}<dnl>
);
        {{ helper message-camelcase-name }}(const {{ helper message-camelcase-name }} &) = delete;
        {{ helper message-camelcase-name }} &operator=({{ helper message-camelcase-name }} const &) = delete;

        {{ helper message-camelcase-name }}({{ helper message-camelcase-name }} &&) = default;
        {{ helper message-camelcase-name }} &operator=({{ helper message-camelcase-name }} &&) = default;
    };

{{ end }}<dnl>

    class DiagnosticMessage {
    public:
        enum class Tag {
{{ each message }}<dnl>
            {{ helper message-upper-name }},
{{ end }}<dnl>
        };

        union Value {
{{ each message }}<dnl>
            {{ helper message-camelcase-name }} {{ helper message-lower-name }};
{{ end }}<dnl>

            Value();
            Value(Value &&);
            ~Value();

            Value &operator=(Value &&);
        };

        Tag tag;
        Value as;

{{ each message }}
        DiagnosticMessage({{ helper message-camelcase-name }} variant);
{{ end }}

        DiagnosticMessage(DiagnosticMessage &&);
        ~DiagnosticMessage();

        DiagnosticMessage &operator=(DiagnosticMessage &&);
    };

    class DiagnosticMessageList
    {
    public:
        DiagnosticMessage *ptr;
        size_t len;
        size_t capacity;

        DiagnosticMessageList() = delete;
        DiagnosticMessageList(DiagnosticMessage *ptr, size_t len, size_t capacity);
        ~DiagnosticMessageList();

        DiagnosticMessageList(const DiagnosticMessageList &) = delete;
        DiagnosticMessageList &operator=(DiagnosticMessageList const &) = delete;

        DiagnosticMessageList(DiagnosticMessageList &&);
        DiagnosticMessageList &operator=(DiagnosticMessageList &&);
    };

#ifdef TEST_ENV
    void run_test_group_message(void);
#endif
} // namespace lib_ruby_parser

#endif // LIB_RUBY_PARSER_MESSAGES_HPP
";

pub(crate) fn codegen() {
    let template = TemplateRoot::new(TEMPLATE).unwrap();
    let fns = crate::codegen::fns::default_fns!();

    let contents = template.render(ALL_DATA, &fns);
    std::fs::write("../messages.hpp", contents).unwrap();
}
