use lib_ruby_parser_nodes::template::*;

const TEMPLATE: &str = "#ifndef LIB_RUBY_PARSER_NODES_HPP
#define LIB_RUBY_PARSER_NODES_HPP

// This file is autogenerated by {{ helper generated-by }}

#include <cstddef>
#include \"string.hpp\"
#include \"loc.hpp\"
#include \"bytes.hpp\"

namespace lib_ruby_parser
{
    class Node;
    class NodeList
    {
    public:
        Node *ptr;
        size_t capacity;
        size_t len;

        NodeList() = delete;
        NodeList(Node *ptr, size_t len, size_t capacity);
        ~NodeList();

        NodeList(const NodeList &) = delete;
        NodeList &operator=(NodeList const &) = delete;

        NodeList(NodeList &&);
        NodeList &operator=(NodeList &&);
    };

{{ each node }}<dnl>
{{ helper node-comment }}
    class {{ helper node-camelcase-name }}
    {
    public:
{{ each node-field }}<dnl>
{{ helper node-field-comment }}
        {{ helper node-field-c-field-type }} {{ helper node-field-c-name }};

{{ end }}<dnl>
    };

{{ end }}<dnl>

    class Node {
    public:
        enum class Tag {
{{ each node }}<dnl>
            {{ helper node-c-enum-variant-name }},
{{ end }}<dnl>
        };

        union Value {
{{ each node }}<dnl>
            {{ helper node-camelcase-name }} {{ helper node-c-union-member-name }};
{{ end }}<dnl>

            Value(Value &&);
            ~Value();

            Value &operator=(Value &&);
        };

        Tag tag;
        Value as;

        Node(Node &&);
        ~Node();

        Node &operator=(Node &&);
    };

#ifdef TEST_ENV
    void run_test_group_node(void);
#endif
} // namespace lib_ruby_parser

#endif // LIB_RUBY_PARSER_NODES_HPP
";

pub(crate) fn codegen() {
    let template = TemplateRoot::new(TEMPLATE).unwrap();
    let fns = crate::codegen::fns::default_fns!();

    let contents = template.render(ALL_DATA, &fns);
    std::fs::write("../nodes.hpp", contents).unwrap();
}
