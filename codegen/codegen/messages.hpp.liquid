#ifndef LIB_RUBY_PARSER_MESSAGES_HPP
#define LIB_RUBY_PARSER_MESSAGES_HPP

// This file is autogenerated by {{ template }}

#include <cstdint>
#include "string.hpp"

namespace lib_ruby_parser
{
    {%- for message in messages %}
    {{ message.comment | render_comment: "///", 4 | replace: "\", "\\" }}
    class {{ message.camelcase_name }}
    {
    public:
        {%- if message.fields.size == 0 %}
        // dummy byte (zero-sized classes are not allowed in C++)
        uint8_t dummy;
        {%- endif %}

        {%- for field in message.fields %}
        {%- case field.field_type -%}
        {%- when "Str" -%}
            {%- assign field_type = "String" -%}
        {%- when "Byte" -%}
            {%- assign field_type = "uint8_t" -%}
        {%- else -%}
            {%- assign field_type = "COMPILE ERROR" -%}
        {%- endcase %}
        {{ field.comment | render_comment: "///", 8 }}
        {{ field_type }} {{ field.snakecase_name | escape_cpp_keyword }};
{% endfor %}

        {%- if message.fields.size > 0 %}
        {{ message.camelcase_name }}() = delete;
        {%- endif %}
        {{ message.camelcase_name }}(
        {%- for field in message.fields %}
        {%- case field.field_type -%}
        {%- when "Str" -%}
            {%- assign field_type = "String" -%}
        {%- when "Byte" -%}
            {%- assign field_type = "uint8_t" -%}
        {%- else -%}
            {%- assign field_type = "COMPILE ERROR" -%}
        {%- endcase %}
            {{ field_type }} {{ field.snakecase_name | escape_cpp_keyword }}{% unless forloop.last %},{% endunless %}
        {%- endfor %});
        {{ message.camelcase_name }}(const {{ message.camelcase_name }} &) = delete;
        {{ message.camelcase_name }} &operator=({{ message.camelcase_name }} const &) = delete;

        {{ message.camelcase_name }}({{ message.camelcase_name }} &&) = default;
        {{ message.camelcase_name }} &operator=({{ message.camelcase_name }} &&) = default;
    };
{% endfor %}

    class DiagnosticMessage {
    public:
        enum class Tag {
            {%- for message in messages %}
            {{ message.camelcase_name | camelcase_to_snakecase | upcase }},
            {%- endfor %}
        };

        union Value {
            {%- for message in messages %}
            {{ message.camelcase_name }} {{ message.camelcase_name | camelcase_to_snakecase }};
            {%- endfor %}

            Value();
            Value(Value &&);
            ~Value();

            Value &operator=(Value &&);
        };

        Tag tag;
        Value as;

        {%- for message in messages %}
        DiagnosticMessage({{ message.camelcase_name }} variant);
        {%- endfor %}

        DiagnosticMessage(DiagnosticMessage &&);
        ~DiagnosticMessage();

        DiagnosticMessage &operator=(DiagnosticMessage &&);
    };

    class DiagnosticMessageList
    {
    public:
        DiagnosticMessage *ptr;
        size_t capacity;
        size_t len;

        DiagnosticMessageList() = delete;
        DiagnosticMessageList(DiagnosticMessage *ptr, size_t len, size_t capacity);
        ~DiagnosticMessageList();

        DiagnosticMessageList(const DiagnosticMessageList &) = delete;
        DiagnosticMessageList &operator=(DiagnosticMessageList const &) = delete;

        DiagnosticMessageList(DiagnosticMessageList &&);
        DiagnosticMessageList &operator=(DiagnosticMessageList &&);
    };

#ifdef TEST_ENV
    void run_test_group_message(void);
#endif
} // namespace lib_ruby_parser

#endif // LIB_RUBY_PARSER_MESSAGES_HPP
