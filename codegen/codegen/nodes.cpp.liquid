// This file is autogenerated by {{ template }}

#include "nodes.hpp"
#include "utils.hpp"

namespace lib_ruby_parser
{
    extern "C"
    {
        void LIB_RUBY_PARSER_drop_node(Node *node);
    }

    Node::Value::Value(Node::Value &&other) {
        std::memcpy(this, &other, sizeof(Value));
        std::memset(&other, 0, sizeof(Value));
    };
    Node::Value::~Value() {}

    Node::Value &Node::Value::operator=(Node::Value &&other) {
        std::memcpy(this, &other, sizeof(Value));
        std::memset(&other, 0, sizeof(Value));
        return *this;
    }

    Node::Node(Node &&other): tag(other.tag), as(std::move(other.as)) {
        std::memset(&other, 0, sizeof(Value));
        // set tag to something we can easily identify in destructor
        // to prevent running deallocation of inner nodes
        // (0 is reserved by the first variant, so we grab the last one and add 1)
        other.tag = static_cast<Node::Tag>(static_cast<int>(Node::Tag::Z_SUPER) + 1);
    }
    Node::~Node() {
        if (static_cast<int>(this->tag) == static_cast<int>(Node::Tag::Z_SUPER) + 1) {
            return;
        }
        LIB_RUBY_PARSER_drop_node(this);
    }

    Node &Node::operator=(Node &&other) {
        this->tag = other.tag;
        this->as = std::move(other.as);
        return *this;
    }

    LIST_IMPL(NodeList, Node, LIB_RUBY_PARSER_drop_node_list);
} // namespace lib_ruby_parser

#ifdef TEST_ENV

#include "test_helper.hpp"

#define assert_expected_node_value(node) \
    assert_eq((node)->tag, Node::Tag::LINE)

#define assert_expected_nodes_value(nodes) \
    assert_eq((nodes).len, 1); \
    assert_expected_node_value(&((nodes).ptr[0]))

#define assert_expected_maybe_node_value(maybe_node) \
    assert_expected_node_value(maybe_node)

#define assert_expected_loc_value(loc) \
    assert_eq((loc).begin, 1); \
    assert_eq((loc).end, 2)

#define assert_expected_maybe_loc_value(maybe_loc) \
    assert_some_loc(maybe_loc, Loc(1, 2))

#define assert_expected_str_value(str) \
    assert_string_eq((str), "foo")

#define assert_expected_maybe_str_value(maybe_str) \
    assert_string_eq((maybe_str).string, "foo")

#define assert_expected_string_value_value(string_value) \
    assert_byte_list((string_value).raw, "\1\2\3")

#define assert_expected_u8_value(u8) \
    assert_eq((u8), 42)

namespace lib_ruby_parser {
    BLOB(Node);
    BLOB(NodeList);

{% for node in nodes %}
    extern "C"
    {
        NodeBlob lib_ruby_parser__test__make_{{ node.camelcase_name | camelcase_to_snakecase }}_node(void);
    }
    static void test_node_{{ node.camelcase_name | camelcase_to_snakecase }}(void)
    {
        annotate_test;

        Node node = from_blob<NodeBlob, Node>(
            lib_ruby_parser__test__make_{{ node.camelcase_name | camelcase_to_snakecase }}_node());
        assert_eq(node.tag, Node::Tag::{{ node.camelcase_name | camelcase_to_snakecase | upcase | escape_cpp_keyword }});
        {{ node.camelcase_name }} *variant = &node.as.{{ node.camelcase_name | camelcase_to_snakecase | escape_cpp_keyword }};
        {%- for field in node.fields %}
        {%- case field.field_type -%}
        {%- when "Node" -%}
            {%- assign assert_fn_name = "assert_expected_node_value" -%}
        {%- when "Nodes" -%}
            {%- assign assert_fn_name = "assert_expected_nodes_value" -%}
        {%- when "MaybeNode" or "RegexpOptions" -%}
            {%- assign assert_fn_name = "assert_expected_maybe_node_value" -%}
        {%- when "Loc" -%}
            {%- assign assert_fn_name = "assert_expected_loc_value" -%}
        {%- when "MaybeLoc" -%}
            {%- assign assert_fn_name = "assert_expected_maybe_loc_value" -%}
        {%- when "Str" or "RawStr" -%}
            {%- assign assert_fn_name = "assert_expected_str_value" -%}
        {%- when "MaybeStr" or "Chars" -%}
            {%- assign assert_fn_name = "assert_expected_maybe_str_value" -%}
        {%- when "StringValue" -%}
            {%- assign assert_fn_name = "assert_expected_string_value_value" -%}
        {%- when "U8" -%}
            {%- assign assert_fn_name = "assert_expected_u8_value" -%}
        {%- else -%}
            {%- assign assert_fn_name = "COMPILE ERROR " -%}
        {%- endcase %}
        {{ assert_fn_name }}(variant->{{ field.snakecase_name | escape_cpp_keyword }});
        {%- endfor %}

        Node node_to_move = from_blob<NodeBlob, Node>(
            lib_ruby_parser__test__make_{{ node.camelcase_name | camelcase_to_snakecase }}_node());
        Node moved = std::move(node_to_move);
    }
{% endfor %}

    extern "C"
    {
        NodeListBlob lib_ruby_parser__test__make_node_list(void);
    }
    static void test_node_list(void)
    {
        annotate_test;

        NodeList node_list = from_blob<NodeListBlob, NodeList>(
            lib_ruby_parser__test__make_node_list());
        assert_expected_nodes_value(node_list);
    }

    void run_test_group_node(void)
    {
        const test_fn_t tests[] = {
            {%- for node in nodes %}
            test_node_{{ node.camelcase_name | camelcase_to_snakecase }},
            {%- endfor %}
            test_node_list,
        };

        run_tests_as_group("node", tests, sizeof(tests) / sizeof(test_fn_t));
    }
} // namespace lib_ruby_parser

#endif
