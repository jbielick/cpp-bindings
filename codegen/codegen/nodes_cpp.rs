use lib_ruby_parser_nodes::{template::*, NodeField};

const TEMPLATE: &str = "// This file is autogenerated by {{ helper generated-by }}

#include \"nodes.hpp\"
#include \"utils.hpp\"

namespace lib_ruby_parser
{
    extern \"C\"
    {
        void LIB_RUBY_PARSER_drop_node(Node *node);
    }

    Node::Value::Value(Node::Value &&other) {
        std::memcpy(this, &other, sizeof(Value));
        std::memset(&other, 0, sizeof(Value));
    };
    Node::Value::~Value() {}

    Node::Value &Node::Value::operator=(Node::Value &&other) {
        std::memcpy(this, &other, sizeof(Value));
        std::memset(&other, 0, sizeof(Value));
        return *this;
    }

    Node::Node(Node &&other): tag(other.tag), as(std::move(other.as)) {
        std::memset(&other, 0, sizeof(Value));
        // set tag to something we can easily identify in destructor
        // to prevent running deallocation of inner nodes
        // (0 is reserved by the first variant, so we grab the last one and add 1)
        other.tag = static_cast<Node::Tag>(static_cast<int>(Node::Tag::Z_SUPER) + 1);
    }
    Node::~Node() {
        if (static_cast<int>(this->tag) == static_cast<int>(Node::Tag::Z_SUPER) + 1) {
            return;
        }
        LIB_RUBY_PARSER_drop_node(this);
    }

    Node &Node::operator=(Node &&other) {
        this->tag = other.tag;
        this->as = std::move(other.as);
        return *this;
    }

    LIST_IMPL(NodeList, Node, LIB_RUBY_PARSER_drop_node_list);
} // namespace lib_ruby_parser

#ifdef TEST_ENV

#include \"test_helper.hpp\"

#define assert_expected_node_value(node) \\
    assert_eq((node)->tag, Node::Tag::LINE)

#define assert_expected_nodes_value(nodes) \\
    assert_eq((nodes).len, 1); \\
    assert_expected_node_value(&((nodes).ptr[0]))

#define assert_expected_maybe_node_value(maybe_node) \\
    assert_expected_node_value(maybe_node)

#define assert_expected_loc_value(loc) \\
    assert_eq((loc).begin, 1); \\
    assert_eq((loc).end, 2)

#define assert_expected_maybe_loc_value(maybe_loc) \\
    assert_some_loc(maybe_loc, Loc(1, 2))

#define assert_expected_str_value(str) \\
    assert_string_eq((str), \"foo\")

#define assert_expected_maybe_str_value(maybe_str) \\
    assert_string_eq((maybe_str).string, \"foo\")

#define assert_expected_string_value_value(string_value) \\
    assert_byte_list((string_value).raw, \"\\1\\2\\3\")

#define assert_expected_u8_value(u8) \\
    assert_eq((u8), 42)

namespace lib_ruby_parser {
    BLOB(Node);
    BLOB(NodeList);

{{ each node }}<dnl>
    extern \"C\"
    {
        NodeBlob lib_ruby_parser__test__make_{{ helper node-lower-name }}_node(void);
    }
    static void test_node_{{ helper node-lower-name }}(void)
    {
        annotate_test;

        Node node = from_blob<NodeBlob, Node>(
            lib_ruby_parser__test__make_{{ helper node-lower-name }}_node());
        assert_eq(node.tag, Node::Tag::{{ helper node-c-enum-variant-name }});
        {{ helper node-camelcase-name }} *variant = &node.as.{{ helper node-c-union-member-name }};
{{ each node-field }}<dnl>
        {{ helper assert-field-fn }}(variant->{{ helper node-field-c-name }});
{{ end }}<dnl>

        Node node_to_move = from_blob<NodeBlob, Node>(
            lib_ruby_parser__test__make_{{ helper node-lower-name }}_node());
        Node moved = std::move(node_to_move);
    }
{{ end }}<dnl>

    extern \"C\"
    {
        NodeListBlob lib_ruby_parser__test__make_node_list(void);
    }
    static void test_node_list(void)
    {
        annotate_test;

        NodeList node_list = from_blob<NodeListBlob, NodeList>(
            lib_ruby_parser__test__make_node_list());
        assert_expected_nodes_value(node_list);
    }

    void run_test_group_node(void)
    {
        const test_fn_t tests[] = {
    {{ each node }}<dnl>
            test_node_{{ helper node-lower-name }},
    {{ end }}<dnl>
            test_node_list,
        };

        run_tests_as_group(\"node\", tests, sizeof(tests) / sizeof(test_fn_t));
    }
} // namespace lib_ruby_parser

#endif
";

pub(crate) fn codegen() {
    let template = TemplateRoot::new(TEMPLATE).unwrap();
    let mut fns = crate::codegen::fns::default_fns!();

    fns.register::<NodeField, F::Helper>("assert-field-fn", helpers::assert_field_fn);

    let contents = template.render(ALL_DATA, &fns);
    std::fs::write("../nodes.cpp", contents).unwrap();
}

mod helpers {
    use lib_ruby_parser_nodes::NodeField;

    pub(crate) fn assert_field_fn(node_field: &NodeField) -> String {
        use lib_ruby_parser_nodes::NodeFieldType::*;

        match node_field.field_type {
            Node => "assert_expected_node_value",
            Nodes => "assert_expected_nodes_value",
            MaybeNode { .. } => "assert_expected_maybe_node_value",
            Loc => "assert_expected_loc_value",
            MaybeLoc => "assert_expected_maybe_loc_value",
            Str { .. } => "assert_expected_str_value",
            MaybeStr { .. } => "assert_expected_maybe_str_value",
            StringValue => "assert_expected_string_value_value",
            U8 => "assert_expected_u8_value",
        }
        .to_string()
    }
}
