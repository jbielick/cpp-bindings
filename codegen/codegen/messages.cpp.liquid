// This file is autogenerated by {{ template }}

#include <cstring>
#include "messages.hpp"
#include "utils.hpp"

namespace lib_ruby_parser
{
    extern "C"
    {
        void LIB_RUBY_PARSER_drop_message(DiagnosticMessage *message);
    }

    DiagnosticMessage::Value::Value() {
        std::memset(this, 0, sizeof(Value));
    }
    DiagnosticMessage::Value::Value(DiagnosticMessage::Value &&other) {
        std::memcpy(this, &other, sizeof(Value));
        std::memset(&other, 0, sizeof(Value));
    };
    DiagnosticMessage::Value::~Value() {}

    DiagnosticMessage::Value &DiagnosticMessage::Value::operator=(DiagnosticMessage::Value &&other) {
        std::memcpy(this, &other, sizeof(Value));
        std::memset(&other, 0, sizeof(Value));
        return *this;
    }

    DiagnosticMessage::DiagnosticMessage(DiagnosticMessage &&other):
        tag(other.tag),
        as(std::move(other.as)) {}
    DiagnosticMessage::~DiagnosticMessage() {
        LIB_RUBY_PARSER_drop_message(this);
    }

    DiagnosticMessage &DiagnosticMessage::operator=(DiagnosticMessage &&other) {
        this->tag = other.tag;
        this->as = std::move(other.as);
        return *this;
    }

    LIST_IMPL(DiagnosticMessageList, DiagnosticMessage, LIB_RUBY_PARSER_drop_message_list);

    // Message variant constructors
    {%- for message in messages %}
    {{ message.camelcase_name }}::{{ message.camelcase_name }}(
    {%- for field in message.fields %}
    {%- case field.field_type -%}
    {%- when "Str" -%}
        {%- assign field_type = "String" -%}
    {%- when "Byte" -%}
        {%- assign field_type = "uint8_t" -%}
    {%- else -%}
        {%- assign field_type = "COMPILE ERROR" -%}
    {%- endcase -%}
        {{ field_type }} {{ field.snakecase_name | escape_cpp_keyword }}_{% unless forloop.last %}, {% endunless %}
    {%- endfor -%})
    {%- if message.fields.size > 0 -%}
        {{" : "}}
        {%- for field in message.fields -%}
            {{ field.snakecase_name | escape_cpp_keyword }}(std::move({{ field.snakecase_name | escape_cpp_keyword }}_))
            {%- unless forloop.last -%}, {% endunless -%}
        {%- endfor -%}
    {%- endif %} {}
{% endfor %}

    // Diagnostic constructors
{% for message in messages %}
    DiagnosticMessage::DiagnosticMessage({{ message.camelcase_name }} variant) : tag(DiagnosticMessage::Tag::{{ message.camelcase_name | camelcase_to_snakecase | upcase }}) {
        this->as.{{ message.camelcase_name | camelcase_to_snakecase }} = std::move(variant);
    }
{% endfor %}
} // namespace lib_ruby_parser

#ifdef TEST_ENV

#include "test_helper.hpp"

#define assert_expected_str_value(str) \
    assert_string_eq((str), "foo")

#define assert_expected_u8_value(u8) \
    assert_eq((u8), 42)

#define assert_expected_messages_value(messages) \
    assert_eq((messages).len, 1); \
    assert_eq((messages).ptr[0].tag, DiagnosticMessage::Tag::FRACTION_AFTER_NUMERIC)

namespace lib_ruby_parser {

    BLOB(DiagnosticMessage);
    BLOB(DiagnosticMessageList);

{% for message in messages %}
    extern "C"
    {
        DiagnosticMessageBlob lib_ruby_parser__test__make_{{ message.camelcase_name | camelcase_to_snakecase }}_message(void);
    }
    static void test_message_{{ message.camelcase_name | camelcase_to_snakecase }}(void)
    {
        annotate_test;

        DiagnosticMessage message = from_blob<DiagnosticMessageBlob, DiagnosticMessage>(
            lib_ruby_parser__test__make_{{ message.camelcase_name | camelcase_to_snakecase }}_message());
        assert_eq(message.tag, DiagnosticMessage::Tag::{{ message.camelcase_name | camelcase_to_snakecase | upcase }});
        {{ message.camelcase_name }} *variant = &message.as.{{ message.camelcase_name | camelcase_to_snakecase }};
        {%- for field in message.fields %}
        {%- case field.field_type -%}
        {%- when "Str" -%}
            {%- assign assert_fn_name = "assert_expected_str_value" -%}
        {%- when "Byte" -%}
            {%- assign assert_fn_name = "assert_expected_u8_value" -%}
        {%- else -%}
            {%- assign assert_fn_name = "COMPILE_ERROR" -%}
        {%- endcase %}
        {{ assert_fn_name }}(variant->{{ field.snakecase_name | escape_cpp_keyword }});
        {%- endfor %}
        (void)variant;

        // make sure it's movable
        DiagnosticMessage message_to_move = from_blob<DiagnosticMessageBlob, DiagnosticMessage>(
            lib_ruby_parser__test__make_{{ message.camelcase_name | camelcase_to_snakecase }}_message());
        DiagnosticMessage moved = std::move(message_to_move);
    }
{% endfor %}

    extern "C"
    {
        DiagnosticMessageListBlob lib_ruby_parser__test__make_message_list(void);
    }
    static void test_message_list(void)
    {
        annotate_test;

        DiagnosticMessageList message_list = from_blob<DiagnosticMessageListBlob, DiagnosticMessageList>(
            lib_ruby_parser__test__make_message_list());
        assert_expected_messages_value(message_list);
    }

    void run_test_group_message(void)
    {
        const test_fn_t tests[] = {
            {%- for message in messages %}
            test_message_{{ message.camelcase_name | camelcase_to_snakecase }},
            {%- endfor %}
            test_message_list,
        };

        run_tests_as_group("message", tests, sizeof(tests) / sizeof(test_fn_t));
    }
}

#endif
