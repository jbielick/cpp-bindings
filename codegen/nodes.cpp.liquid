// This file is autogenerated by {{ template }}

#include "nodes.hpp"
#include "utils.hpp"

namespace lib_ruby_parser
{
    extern "C"
    {
        void LIB_RUBY_PARSER_drop_node(Node *node);
    }

    Node::Value::Value(Node::Value &&other) {
        std::memcpy(this, &other, sizeof(Value));
        std::memset(&other, 0, sizeof(Value));
    };
    Node::Value::~Value() {}

    Node::Value &Node::Value::operator=(Node::Value &&other) {
        std::memcpy(this, &other, sizeof(Value));
        std::memset(&other, 0, sizeof(Value));
        return *this;
    }

    Node::Node(Node &&other): tag(other.tag), as(std::move(other.as)) {
        std::memset(&other, 0, sizeof(Value));
        // set tag to something we can easily identify in destructor
        // to prevent running deallocation of inner nodes
        // (0 is reserved by the first variant, so we grab the last one and add 1)
        other.tag = static_cast<Node::Tag>(static_cast<int>(Node::Tag::Z_SUPER) + 1);
    }
    Node::~Node() {
        if (static_cast<int>(this->tag) == static_cast<int>(Node::Tag::Z_SUPER) + 1) {
            return;
        }
        LIB_RUBY_PARSER_drop_node(this);
    }

    Node &Node::operator=(Node &&other) {
        this->tag = other.tag;
        this->as = std::move(other.as);
        return *this;
    }

    LIST_IMPL(NodeList, Node, LIB_RUBY_PARSER_drop_node_list);
} // namespace lib_ruby_parser
